%
%  Introduction
%

%-- Chapter Title
\chapter{Introduction}

Web applications are a fundamental part of our lives and culture. We
use web applications in almost every facet of society: socializing,
banking, health care, taxes, education, and news, to name a few. These
web applications are always available from anywhere with an Internet
connection, and they enable us to communicate and collaborate at a
speed that was unthinkable just a few decades ago.

The shift of having more and more of our lives and data move to web
applications unfortunately attracts hackers. In 2011, hackers stole 1
million usernames and passwords from Sony~\cite{bilton11:sony}. In
2008, hackers stole 45 million customer credit cards from TJ Maxx. In
2009, hackers stole 100 million customer credit cards from Heartland
Payment Systems. In 2012, hackers stole 24,000 Bitcoins\footnote{These
  Bitcoins are worth about \$10 million at this time of writing.} from
BitFloor, a major Bitcoin exchange. What all of these instances have
in common is that hackers exploited vulnerabilities in a web
application in order to steal either usernames and passwords, credit
cards, or Bitcoins.

It is insightful to turn our attention to \emph{why} web applications
have so many vulnerabilities. Those same properties that make web
applications so attractive to users also attract hackers. A web
application never closes, so they are always available for hackers.
Web applications also house a vast treasure-trove of data, which
hackers can use for monetary gain. Finally, as we will explore in the
next section, web applications are a complex hodgepodge of various
technologies. This complexity, combined with the intense
time-to-market pressure of web applications, is a breeding ground for
bugs and vulnerabilities.

The situation is dire. We must focus on new ways to secure web
applications from attack. We must develop new tools in order to find
the vulnerabilities before a hacker does. We must, because web
applications and they data we store on them are too important.

\section{History of Web Applications}

The World Wide Web was created by Sir.\ Tim Berners-Lee in 1989 as a
means of sharing information for the CERN research organization. What
began is a means of sharing simple hyper-linked textual documents,
quickly exploded in popularity over the proceeding years.

The core of the web has remained relatively the same throughout the
years: a web browser (operated by a user) connects to a web server
using the Hypertext Transfer Protocol (HTTP)~\cite{fielding99:http11}.
The web server then sends back a response, typically in the form of a
HyperText Markup Language (HTML) page~\cite{berjon14:html5}. The web
browser then parses the raw HTML page to turn it into a GUI that is
displayed to the user. The fundamental underlying principle, and the
definition of HyperText, is that an HTML page contains links to
\emph{other} HTML pages.

The beginning of the web was envisioned as a set of documents with
links pointing to other documents. In other words, the web was mostly
a set of read-only documents (from the perspective of the user with
the web browser). This is where the term \emph{web sites} comes from:
a web site is typically thought of as a collection of documents that
exist under the same domain name.

As the web evolved, web sites started to shift from static, read-only
documents. Developers realized that the HTML response returned to the
client could be dynamic---that is, the content of the HTML response
could vary pragmatically. This shift in thinking caused web sites to
transition to \emph{web applications} which emulated features of
traditional desktop applications. Web applications enabled scenarios
that caused the web's popular to increase: e-commerce, news sites, and
web-based email. It is hard to overstate the impact that web
applications had on the uptake of the web. 

Now, with web applications, the architecture of the web changed
slightly. When the web browser makes an HTTP request to the server,
instead of returning a static HTML response, the web server typically
will invoke server-side code. This server-side code is responsible for
returning a response, typically HTML, to the browser. The server-side
code can use any number of inputs to determine the response, but the
typical set-up is that the server-side reads the parameters sent in
the browser's HTTP request, consults an SQL database, and returns an
HTML response. 

This architecture of a web application is what we will use throughout
this chapter to discuss the security aspects of web applications.

\section{Web Application Vulnerabilities}

The security properties of a web application are similar to the
security of any other application: confidentially of the data,
integrity of the data, and availability of the application. In this
dissertation, we will focus on attacks that compromise the
confidentially or integrity of the web application's data.

\subsection{Injection Vulnerabilities}

Injection vulnerabilities are to web applications as memory-corruption
vulnerabilities are to binary applications. 

This class of vulnerabilities occur when an attacker is able to
control or influence the value of parameters that are used as part of
an outside (to the language) query, command, or language. If the
attacker can manipulate and change the semantics of the query,
command, or language, and this compromises the security of the
application, then that is an injection vulnerabilities.

There are many types of injection vulnerabilities in web applications,
and the types depend on the query, command, or language that is being
injected. These include SQL queries, HTML responses, OS commands,
email headers, HTTP headers, and many more. Next we will focus on two
of the most serious and prevalent classes of injection
vulnerabilities: SQL injection and Cross-Site Scripting (XSS).

\subsubsection{SQL Injection}

SQL injection vulnerabilities, while declining in the number reported
when compared to XSS vulnerabilities, are sill numerous and are
incredibly critical when they occur.

The root cause of SQL injection vulnerabilities is that the
server-side code of the web application, in order to issue an SQL
query to the SQL database, concatenates strings together. This form
allows the queries to be parameterized, and therefore the server-side
code can be more general. The problem is that, according to the
server-side language, the resulting query is simply a string, whereas
when that string is passed to the SQL server, the SQL server parses
the string into a SQL query. Therefore, what the server-side code
treats as a simple string is in fact a complex language. 

\textbf{Need example}

Thus, in order for an attacker to not alter the semantics of the SQL
query, a web developer must be careful to properly \emph{sanitize} all
potentially attacker-control input. Here sanitize means to transform
the input from the user to a form that renders it neutral for the
target language. In the case of SQL, this typically means converting
any \texttt{\textquotesingle} (which are used by an attacker to escape
out of an SQL query) to the inert
\texttt{\textbackslash\textquotesingle}.

So what damage can an attacker cause by exploiting an SQL injection
vulnerability? An attacker can violate both the confidentially and
integrity of the application's data. An attacker can insert arbitrary
data into the database, potentially adding a new admin user to the web
application. Also, an attacker can exfiltrate any data that the
database user can access (typically all data that the application can
access). Finally, the attacker can also delete all of the data that
the web application has access to. These consequences of a single SQL
injection vulnerability are why SQL injection vulnerabilities are so
severe.

To prevent SQL injections with sanitization, a developer must be
extremely careful that no user-supplied data is used in an SQL
statement, including any paths that the data could have taken through
the web application. In practice, this is (understandably) difficult
for developers to always accomplish. Therefore, developers should use
\emph{prepared statements,} which is a way to tell the database the
structure of an SQL query \emph{before} the data is given. In this
way, the database already knows the structure of the SQL query, and
therefore there is no way for an attacker to alter the structure and
semantics of the query. Almost every server-side language or framework
has support for prepared statements.

\subsubsection{Cross-Site Scripting}

Cross-Site Scripting (XSS) vulnerabilities are similar in spirit to
SQL injection vulnerabilities. 

\subsection{Logic Flaws}

\section{Securing Web Applications}

\subsection{Anomaly Detection}

\subsection{Secure Construction}

\section{Vulnerability Analysis Tools}

\subsection{White-Box}

\subsection{Black-Box}

\subsection{Grey-Box}



New section without a title, this is what this dissertation is going
to be about.



% --------------------------------------------------------------------
% Thesis Statement
% --------------------------------------------------------------------
%% \pagebreak
%% \section*{Thesis Statement}

%% Is this something I need? Did wkr have it?



